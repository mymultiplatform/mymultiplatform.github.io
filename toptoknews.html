<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Psychedelic 3D Stamp (WebGL/Three.js)</title>
<style>
  html,body{margin:0;height:100%;background:#0b0a10;color:#eee;font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif}
  #c{display:block;width:100vw;height:100vh;touch-action:none}
  .ui{
    position:fixed; inset:auto 10px 10px auto; display:flex; flex-direction:column; gap:.5rem;
    background:rgba(10,10,14,.6); backdrop-filter: blur(10px);
    border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:.8rem; max-width:92vw
  }
  .row{display:flex; align-items:center; gap:.5rem}
  .row label{font-size:.85rem; opacity:.9; min-width:5.5rem}
  .row input[type="range"]{width:180px}
  .buttons{display:flex; gap:.5rem; flex-wrap:wrap}
  button{
    font:inherit; color:#fff; background:#3a3ade; border:none; border-radius:10px; padding:.6rem .8rem;
    box-shadow: 0 6px 18px rgba(58,58,222,.3); cursor:pointer
  }
  button.secondary{background:#2b2b34; box-shadow:none}
  a.dl{color:#9fe8ff; text-decoration:none; font-size:.9rem}
  .hint{font-size:.78rem; opacity:.75; line-height:1.2}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui" role="region" aria-label="controls">
  <div class="row"><label>Speed</label><input id="speed" type="range" min="0" max="2.0" step="0.01" value="1.0"><span id="speedv">1.00x</span></div>
  <div class="row"><label>Hue Drift</label><input id="hue" type="range" min="0" max="360" step="1" value="120"><span id="huev">120°</span></div>
  <div class="row"><label>Detail</label><input id="detail" type="range" min="0.5" max="2.0" step="0.01" value="1.0"><span id="detailv">1.00</span></div>
  <div class="buttons">
    <button id="toggle">Pause</button>
    <button id="record">Record</button>
    <button id="randomize" class="secondary">Randomize</button>
    <a id="download" class="dl" style="display:none" href="#" download="psychedelic-stamp.webm">Download video</a>
  </div>
  <div class="hint">Tip: For highest quality, open on desktop and hit <b>Record</b>. On iPhone, use the built-in screen recorder while this page plays full screen.</div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import {OrbitControls} from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, powerPreference:'high-performance'});
// Supersampling-like scale (kept conservative for phones)
const SCALE = window.devicePixelRatio > 2 ? 1.5 : 2.0; // adjust if too heavy on phone
resize(); window.addEventListener('resize', resize);

const scene = new THREE.Scene();
// Subtle stage gradient via fog + clear color
scene.fog = new THREE.Fog(new THREE.Color(0x0b0a10), 6, 22);
renderer.setClearColor(0x06050a, 1);

const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 100);
camera.position.set(0, 0.6, 6);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableZoom = false; controls.enablePan = false; controls.enableDamping = true; controls.dampingFactor = 0.06; controls.minPolarAngle = 0.9; controls.maxPolarAngle = 2.2;

// Lighting (rim + faint ambient)
const ambient = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambient);
const rim = new THREE.DirectionalLight(0xffffff, 1.4);
rim.position.set(-2, 3, 2);
scene.add(rim);

// Psychedelic shader material: animated normals + iridescent color cycle
const uniforms = {
  uTime: {value: 0},
  uHue:  {value: 120.0 * Math.PI/180.0},
  uDetail: {value: 1.0},
  uSpeed: {value: 1.0},
};

// Vertex warping: sine-turbulence for a living surface
const vtx = /* glsl */`
varying vec3 vPos;
varying vec3 vNormal;
uniform float uTime;
uniform float uDetail;
uniform float uSpeed;

float n3(vec3 p){
  return sin(p.x)+sin(p.y*1.732)+sin(p.z*2.113);
}
void main(){
  vPos = position;
  float t = uTime * uSpeed * 0.8;
  // multi-octave swirl
  vec3 p = position;
  float r = length(p.xy)+0.0001;
  float ang = atan(p.y,p.x) + 0.25*sin(2.0*r + t);
  p.x = cos(ang)*r;
  p.y = sin(ang)*r;

  float wob =
      0.18 * sin(3.0*p.x + t*1.2)
    + 0.14 * sin(4.0*p.y - t*1.4)
    + 0.10 * sin(5.0*p.z + t*1.7);
  wob *= uDetail;
  vec3 displaced = p + normal * wob;

  // compute a smoother normal by nudging neighbors
  float eps = 0.0025;
  vec3 dx = vec3(eps,0.0,0.0);
  vec3 dy = vec3(0.0,eps,0.0);
  vec3 dz = vec3(0.0,0.0,eps);
  vec3 px = position + dx; vec3 py = position + dy; vec3 pz = position + dz;
  float wobx = 0.18*sin(3.0*px.x+t*1.2)+0.14*sin(4.0*px.y-t*1.4)+0.10*sin(5.0*px.z+t*1.7);
  float woby = 0.18*sin(3.0*py.x+t*1.2)+0.14*sin(4.0*py.y-t*1.4)+0.10*sin(5.0*py.z+t*1.7);
  float wobz = 0.18*sin(3.0*pz.x+t*1.2)+0.14*sin(4.0*pz.y-t*1.4)+0.10*sin(5.0*pz.z+t*1.7);
  vec3 nx = normalize(cross(dy, (normal*wobx - normal*wob)));
  vec3 ny = normalize(cross(dz, (normal*woby - normal*wob)));
  vNormal = normalize(nx + ny + normal);

  gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
}
`;

// Fragment: iridescent bands + rim lighting + hue rotation
const frg = /* glsl */`
precision highp float;
varying vec3 vPos;
varying vec3 vNormal;
uniform float uTime;
uniform float uHue;
uniform float uDetail;
uniform float uSpeed;

// hsv → rgb
vec3 hsv2rgb(vec3 c){
  vec3 p = abs(fract(c.xxx + vec3(0.,2./6.,4./6.))*6. - 3.);
  return c.z * mix(vec3(1.), clamp(p - 1., 0., 1.), c.y);
}

void main(){
  // anime rim
  vec3 N = normalize(vNormal);
  vec3 V = normalize(vec3(0.,0.,1.5));
  float rim = pow(1.0 - max(dot(N, V), 0.0), 1.6);
  float t = uTime * uSpeed;

  // psychedelic bands that swirl over the surface
  float bands = sin(6.0*length(vPos.xy) + t*2.1) + sin(5.0*vPos.z - t*1.7);
  bands += 0.5*sin(12.0*atan(vPos.y, vPos.x) + t*1.2);
  bands *= 0.5 + 0.5*sin(t*0.7);

  float sparkle = smoothstep(0.5, 1.0, rim) * (0.75 + 0.25*sin(t*5.0 + vPos.z*10.0));

  float hue = uHue + 0.6 * bands + 0.25 * sin(t*0.5);
  hue = mod(hue, 6.28318530718); // wrap 0..2π
  float H = hue / 6.28318530718; // 0..1
  float S = 0.85;
  float Vv = 0.55 + 0.45 * sparkle;

  vec3 col = hsv2rgb(vec3(H, S, Vv));
  // soft fog mix to background for depth
  float depth = clamp(length(vPos)*0.14, 0.0, 1.0);
  col = mix(vec3(0.06,0.05,0.1), col, 1.0 - depth*0.4);

  gl_FragColor = vec4(col, 1.0);
}
`;

const material = new THREE.ShaderMaterial({
  uniforms, vertexShader: vtx, fragmentShader: frg, lights: false
});

// TorusKnot = classic “logo” shape; dense for smooth deforms
const geo = new THREE.TorusKnotGeometry(1.1, 0.35, 720, 96, 2, 3);
const mesh = new THREE.Mesh(geo, material);
scene.add(mesh);

// Floor ghost (gives a nice stage reflection vibe)
const floor = new THREE.Mesh(
  new THREE.CircleGeometry(4.0, 64),
  new THREE.MeshBasicMaterial({color:0x1a1824, transparent:true, opacity:0.55})
);
floor.rotation.x = -Math.PI/2;
floor.position.y = -1.7;
scene.add(floor);

// UI wires
const elSpeed = document.getElementById('speed');
const elHue = document.getElementById('hue');
const elDetail = document.getElementById('detail');
const elSpeedV = document.getElementById('speedv');
const elHueV = document.getElementById('huev');
const elDetailV = document.getElementById('detailv');

elSpeed.oninput = () => { uniforms.uSpeed.value = parseFloat(elSpeed.value); elSpeedV.textContent = `${(+elSpeed.value).toFixed(2)}x`; };
elHue.oninput = () => { uniforms.uHue.value = (+elHue.value)*Math.PI/180; elHueV.textContent = `${elHue.value}°`; };
elDetail.oninput = () => { uniforms.uDetail.value = parseFloat(elDetail.value); elDetailV.textContent = (+elDetail.value).toFixed(2); };
document.getElementById('randomize').onclick = () => {
  elHue.value = (Math.random()*360)|0; elHue.oninput();
  elSpeed.value = (Math.random()*1.5+0.5).toFixed(2); elSpeed.oninput();
  elDetail.value = (Math.random()*1.0+0.8).toFixed(2); elDetail.oninput();
};

let running = true;
document.getElementById('toggle').onclick = () => {
  running = !running;
  document.getElementById('toggle').textContent = running ? 'Pause' : 'Play';
};

let mediaRecorder, chunks=[];
const recBtn = document.getElementById('record');
const dl = document.getElementById('download');

function canRecord(){
  // try the most common webm mime on desktop
  return !!(canvas.captureStream && ('MediaRecorder' in window) && MediaRecorder.isTypeSupported('video/webm;codecs=vp9') || MediaRecorder.isTypeSupported('video/webm;codecs=vp8') || MediaRecorder.isTypeSupported('video/webm'));
}

if(!canRecord()){
  recBtn.textContent = 'Record (unsupported)';
  recBtn.disabled = true;
}

recBtn.onclick = () => {
  if(mediaRecorder && mediaRecorder.state === 'recording'){
    mediaRecorder.stop();
    recBtn.textContent = 'Record';
    return;
  }
  const stream = canvas.captureStream(60);
  let mime = 'video/webm;codecs=vp9';
  if(!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm;codecs=vp8';
  if(!MediaRecorder.isTypeSupported(mime)) mime = 'video/webm';
  mediaRecorder = new MediaRecorder(stream, {mimeType: mime, videoBitsPerSecond: 8_000_000});
  chunks = [];
  mediaRecorder.ondataavailable = e => { if(e.data.size) chunks.push(e.data); };
  mediaRecorder.onstop = () => {
    const blob = new Blob(chunks, {type: chunks[0]?.type || 'video/webm'});
    const url = URL.createObjectURL(blob);
    dl.href = url; dl.style.display='inline'; // show link
  };
  mediaRecorder.start();
  recBtn.textContent = 'Stop';
};

// Animation loop
let t0 = performance.now();
function frame(now){
  const dt = (now - t0) / 1000;
  t0 = now;
  if(running){
    uniforms.uTime.value += dt;
    // gentle auto-rotation (DVD-logo vibe, but 3D)
    mesh.rotation.y += 0.35 * dt * uniforms.uSpeed.value;
    mesh.rotation.x += 0.12 * dt * uniforms.uSpeed.value;
  }
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// Resize / supersample
function resize(){
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h; camera.updateProjectionMatrix();
  renderer.setPixelRatio(Math.min(window.devicePixelRatio * (SCALE/2), 2.5));
  renderer.setSize(w, h, false);
}
</script>
</body>
</html>